[
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A developer needs to display the total Billable_Hours__c from related Project__c records on each Account record. Which relationship type is required to create a roll-up summary field for this requirement? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Roll-up summary fields aggregate child data (SUM, COUNT, MIN, MAX) on the parent record. They only work with master-detail relationships because the tight coupling guarantees referential integrity. Lookup relationships are too loose -- child records can exist without a parent, making aggregation unreliable.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/point_click_business_logic/roll_up_summary_fields",
    "isPremium": false,
    "answers": [
      {
        "content": "Lookup relationship",
        "isCorrect": false
      },
      {
        "content": "Master-Detail relationship",
        "isCorrect": true
      },
      {
        "content": "External Lookup relationship",
        "isCorrect": false
      },
      {
        "content": "Indirect Lookup relationship",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A developer needs to display the total Credits__c from related Enrollment__c records on each Course__c record. Which relationship type is required to create a roll-up summary field for this requirement? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Master-detail relationships enable roll-up summary fields because child records cannot exist without the parent (cascade delete). External and indirect lookups are for connecting to external data sources, not for roll-up summaries.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/point_click_business_logic/roll_up_summary_fields",
    "isPremium": false,
    "answers": [
      {
        "content": "Lookup relationship",
        "isCorrect": false
      },
      {
        "content": "Master-Detail relationship",
        "isCorrect": true
      },
      {
        "content": "External Lookup relationship",
        "isCorrect": false
      },
      {
        "content": "Indirect Lookup relationship",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "The business wants to show the average Amount from related Opportunity records on the Account. Which configuration meets this requirement without code? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Roll-up summary fields only support SUM, COUNT, MIN, and MAX -- there is no AVG type. The workaround is to create two roll-ups (SUM and COUNT) and a formula field that divides them. Formula fields on the child cannot push values to the parent. Workflow rules are being retired in favor of flows.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/point_click_business_logic/roll_up_summary_fields",
    "isPremium": false,
    "answers": [
      {
        "content": "Create a roll-up summary field using the AVG roll-up type",
        "isCorrect": false
      },
      {
        "content": "Create SUM and COUNT roll-up summary fields and divide them in a formula field",
        "isCorrect": true
      },
      {
        "content": "Create a formula field on the child to push the value to the parent",
        "isCorrect": false
      },
      {
        "content": "Use a workflow rule to update the parent",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "The business wants to show the average Score__c from related Enrollment__c records on the Course__c. Which configuration meets this requirement without code? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Roll-up summary fields only support SUM, COUNT, MIN, and MAX -- there is no AVG type. The workaround is to create two roll-ups (SUM and COUNT) and a formula field that divides them. Formula fields on the child cannot push values to the parent. Workflow rules are being retired in favor of flows.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/point_click_business_logic/roll_up_summary_fields",
    "isPremium": false,
    "answers": [
      {
        "content": "Create a roll-up summary field using the AVG roll-up type",
        "isCorrect": false
      },
      {
        "content": "Create SUM and COUNT roll-up summary fields and divide them in a formula field",
        "isCorrect": true
      },
      {
        "content": "Create a formula field on the child to push the value to the parent",
        "isCorrect": false
      },
      {
        "content": "Use a workflow rule to update the parent",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A company needs to relate Student__c and Course__c so each can be related to many of the other, and they must store Grade__c on the association. What should the developer build? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Salesforce has no native many-to-many relationship. You create one with a junction object containing two master-detail fields, one to each parent. The junction object can hold extra data (like Grade or Start_Date) on the relationship itself. Lookups alone cannot cascade delete or provide roll-up summaries.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/data_modeling",
    "isPremium": false,
    "answers": [
      {
        "content": "Two lookup fields on Student__c",
        "isCorrect": false
      },
      {
        "content": "A junction object with two master-detail relationships",
        "isCorrect": true
      },
      {
        "content": "A single master-detail relationship from Course__c to Student__c",
        "isCorrect": false
      },
      {
        "content": "An external object with an indirect lookup",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A company needs to relate Event__c and Speaker__c so each can be related to many of the other, and they must store Topic__c on the association. What should the developer build? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Salesforce has no native many-to-many relationship. You create one with a junction object containing two master-detail fields, one to each parent. The junction object can hold extra data (like Grade or Start_Date) on the relationship itself. Lookups alone cannot cascade delete or provide roll-up summaries.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/data_modeling",
    "isPremium": false,
    "answers": [
      {
        "content": "Two lookup fields on Event__c",
        "isCorrect": false
      },
      {
        "content": "A junction object with two master-detail relationships",
        "isCorrect": true
      },
      {
        "content": "A single master-detail relationship from Speaker__c to Event__c",
        "isCorrect": false
      },
      {
        "content": "An external object with an indirect lookup",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A company needs to relate Vehicle__c and Driver__c so each can be related to many of the other, and they must store Start_Date__c on the association. What should the developer build? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Salesforce has no native many-to-many relationship. You create one with a junction object containing two master-detail fields, one to each parent. The junction object can hold extra data (like Grade or Start_Date) on the relationship itself. Lookups alone cannot cascade delete or provide roll-up summaries.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/data_modeling",
    "isPremium": false,
    "answers": [
      {
        "content": "Two lookup fields on Vehicle__c",
        "isCorrect": false
      },
      {
        "content": "A junction object with two master-detail relationships",
        "isCorrect": true
      },
      {
        "content": "A single master-detail relationship from Driver__c to Vehicle__c",
        "isCorrect": false
      },
      {
        "content": "An external object with an indirect lookup",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "Records from an ERP system are synced nightly into Account. The integration must upsert without creating duplicates. Which field should be created to match records? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "External ID fields let the upsert operation match incoming records to existing Salesforce records using the external system's unique identifier. If a match is found, the record is updated; if not, a new record is inserted. Auto Number fields are system-generated and cannot be set by integrations. Formula fields are read-only.",
    "referenceUrl": "https://help.salesforce.com/s/articleView?id=sf.data_loader.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Auto Number",
        "isCorrect": false
      },
      {
        "content": "External ID",
        "isCorrect": true
      },
      {
        "content": "Formula (Text)",
        "isCorrect": false
      },
      {
        "content": "Roll-Up Summary",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "Records from a point-of-sale system are synced nightly into Order__c. The integration must upsert without creating duplicates. Which field should be created to match records? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "External ID fields let the upsert operation match incoming records to existing Salesforce records using the external system's unique identifier. If a match is found, the record is updated; if not, a new record is inserted. Auto Number fields are system-generated and cannot be set by integrations. Formula fields are read-only.",
    "referenceUrl": "https://help.salesforce.com/s/articleView?id=sf.data_loader.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Auto Number",
        "isCorrect": false
      },
      {
        "content": "External ID",
        "isCorrect": true
      },
      {
        "content": "Formula (Text)",
        "isCorrect": false
      },
      {
        "content": "Roll-Up Summary",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "Records from a legacy ticketing system are synced nightly into Case. The integration must upsert without creating duplicates. Which field should be created to match records? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "External ID fields let the upsert operation match incoming records to existing Salesforce records using the external system's unique identifier. If a match is found, the record is updated; if not, a new record is inserted. Auto Number fields are system-generated and cannot be set by integrations. Formula fields are read-only.",
    "referenceUrl": "https://help.salesforce.com/s/articleView?id=sf.data_loader.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Auto Number",
        "isCorrect": false
      },
      {
        "content": "External ID",
        "isCorrect": true
      },
      {
        "content": "Formula (Text)",
        "isCorrect": false
      },
      {
        "content": "Roll-Up Summary",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "An admin must load 200,000 Lead records and repeat the load every night. Which tool should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Data Loader handles up to 5 million records and supports command-line/batch mode for scheduled operations. Data Import Wizard is limited to 50,000 records and has no automation capability. Schema Builder designs data models; Report Export only reads data.",
    "referenceUrl": "https://help.salesforce.com/s/articleView?id=sf.data_loader.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Data Import Wizard",
        "isCorrect": false
      },
      {
        "content": "Data Loader",
        "isCorrect": true
      },
      {
        "content": "Report Export",
        "isCorrect": false
      },
      {
        "content": "Schema Builder",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "An admin must load 1.5 million OpportunityLineItem records and repeat the load each month. Which tool should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Data Loader handles up to 5 million records and supports command-line/batch mode for scheduled operations. Data Import Wizard is limited to 50,000 records and has no automation capability. Schema Builder designs data models; Report Export only reads data.",
    "referenceUrl": "https://help.salesforce.com/s/articleView?id=sf.data_loader.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Data Import Wizard",
        "isCorrect": false
      },
      {
        "content": "Data Loader",
        "isCorrect": true
      },
      {
        "content": "Report Export",
        "isCorrect": false
      },
      {
        "content": "Schema Builder",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "Users need different Case page layouts and picklist values for Product Support versus Billing. Which feature supports this? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "\u2705 Record Types control the user experience by determining which page layouts, picklist values, and business processes users see. Different record types on the same object can have completely different fields and workflows, enabling multiple business processes on one object.\n\n\u274c Profiles control access but not page layouts per record. Page layouts are assigned to record types. Workflow rules don't control UI elements.\n\n\ud83d\udca1 Each record type can have its own page layout assignment and picklist value selections, making them essential for supporting different business units or processes.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/projects/customize-a-salesforce-object/create-record-types",
    "isPremium": false,
    "answers": [
      {
        "content": "Field history tracking",
        "isCorrect": false
      },
      {
        "content": "Record Types",
        "isCorrect": true
      },
      {
        "content": "Validation rules",
        "isCorrect": false
      },
      {
        "content": "Assignment rules",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "Users need different Opportunity page layouts and picklist values for New Business versus Renewal. Which feature supports this? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "\u2705 Record Types control the user experience by determining which page layouts, picklist values, and business processes users see. Different record types on the same object can have completely different fields and workflows, enabling multiple business processes on one object.\n\n\u274c Profiles control access but not page layouts per record. Page layouts are assigned to record types. Workflow rules don't control UI elements.\n\n\ud83d\udca1 Each record type can have its own page layout assignment and picklist value selections, making them essential for supporting different business units or processes.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/projects/customize-a-salesforce-object/create-record-types",
    "isPremium": false,
    "answers": [
      {
        "content": "Field history tracking",
        "isCorrect": false
      },
      {
        "content": "Record Types",
        "isCorrect": true
      },
      {
        "content": "Validation rules",
        "isCorrect": false
      },
      {
        "content": "Assignment rules",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A developer wants a visual way to view and edit the Recruiting data model, including adding fields and relationships to Position__c. Which tool should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Schema Builder is a drag-and-drop tool for viewing and editing the data model visually. You can create objects, add fields, and define relationships directly on the canvas. Data Loader is for importing/exporting data, not designing schemas. Change Sets deploy metadata between orgs.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/data_modeling/schema_builder",
    "isPremium": false,
    "answers": [
      {
        "content": "Schema Builder",
        "isCorrect": true
      },
      {
        "content": "Data Loader",
        "isCorrect": false
      },
      {
        "content": "Change Sets",
        "isCorrect": false
      },
      {
        "content": "Debug Logs",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A developer wants a visual way to view and edit the Nonprofit data model, including adding fields and relationships to Grant__c. Which tool should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Schema Builder is a drag-and-drop tool for viewing and editing the data model visually. You can create objects, add fields, and define relationships directly on the canvas. Data Loader is for importing/exporting data, not designing schemas. Change Sets deploy metadata between orgs.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/data_modeling/schema_builder",
    "isPremium": false,
    "answers": [
      {
        "content": "Schema Builder",
        "isCorrect": true
      },
      {
        "content": "Data Loader",
        "isCorrect": false
      },
      {
        "content": "Change Sets",
        "isCorrect": false
      },
      {
        "content": "Debug Logs",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A global search needs to find records containing 'Acme' across Account, Contact, and Opportunity. Which query language should be used? Choose 1 answer.",
    "codeSnippet": "// SOSL searches across multiple objects\nList<List<SObject>> searchResults = [\n    FIND 'Acme'\n    IN ALL FIELDS\n    RETURNING Account(Id, Name), Contact(Id, Name), Opportunity(Id, Name)\n];\n\n// Results grouped by object type\nList<Account> accounts = (List<Account>) searchResults[0];\nList<Contact> contacts = (List<Contact>) searchResults[1];\nList<Opportunity> opps = (List<Opportunity>) searchResults[2];",
    "explanation": "\u2705 SOSL (Salesforce Object Search Language) is designed for text-based searches across multiple objects and fields simultaneously. It returns a list of lists, grouped by object type, making it ideal for global search scenarios like searching 'Acme' across Accounts, Contacts, and Opportunities.\n\n\u274c SOQL searches one object at a time (though it can query related objects via relationships). For unrelated objects, you'd need multiple SOQL queries.\n\n\ud83d\udca1 Remember: SOSL = Search Over Salesforce across multiple objects; SOQL = Query structured data from one object tree.",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.soql_sosl.meta/soql_sosl/sforce_api_calls_sosl.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "SOSL",
        "isCorrect": true
      },
      {
        "content": "SOQL",
        "isCorrect": false
      },
      {
        "content": "SQL",
        "isCorrect": false
      },
      {
        "content": "GraphQL",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A global search needs to find records containing 'Highlander' across Lead and Account. Which query language should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "\u2705 SOSL performs text-based searches across multiple objects simultaneously. When searching for 'Highlander' across Lead and Account, SOSL searches Name, Email, and other searchable fields on both objects in one query.\n\n\u274c SOQL would require two separate queries\u2014one for Lead, one for Account\u2014because these objects aren't related. SOSL is more efficient for this use case.\n\n\ud83d\udca1 SOSL syntax: FIND {SearchTerm} IN ALL FIELDS RETURNING Lead, Account",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.soql_sosl.meta/soql_sosl/sforce_api_calls_sosl.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "SOSL",
        "isCorrect": true
      },
      {
        "content": "SOQL",
        "isCorrect": false
      },
      {
        "content": "SQL",
        "isCorrect": false
      },
      {
        "content": "GraphQL",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A developer needs to retrieve Account records along with their related Contacts in a single query. Which SOQL relationship query should be used? Choose 1 answer.",
    "codeSnippet": "// Parent-to-child subquery (relationship query)\nList<Account> accounts = [\n    SELECT Id, Name,\n        (SELECT Id, FirstName, LastName, Email FROM Contacts)\n    FROM Account\n    WHERE Industry = 'Technology'\n];\n\n// Access child records\nfor (Account acc : accounts) {\n    for (Contact con : acc.Contacts) {\n        System.debug(acc.Name + ' - ' + con.FirstName);\n    }\n}",
    "explanation": "A parent-to-child subquery (SELECT Id, Name, (SELECT Id FROM Contacts) FROM Account) returns the parent and all its children in one SOQL query. Child-to-parent dot notation (Contact.Account.Name) traverses upward, not downward. SOSL is for text search, not structured relationship queries.",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.soql_sosl.meta/soql_sosl/sforce_api_calls_soql_relationships.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Parent-to-child subquery",
        "isCorrect": true
      },
      {
        "content": "Child-to-parent dot notation",
        "isCorrect": false
      },
      {
        "content": "SOSL",
        "isCorrect": false
      },
      {
        "content": "Aggregate query only",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A developer needs to retrieve Case records along with their related CaseComments in a single query. Which SOQL relationship query should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "A parent-to-child subquery (SELECT Id, Name, (SELECT Id FROM Contacts) FROM Account) returns the parent and all its children in one SOQL query. Child-to-parent dot notation (Contact.Account.Name) traverses upward, not downward. SOSL is for text search, not structured relationship queries.",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.soql_sosl.meta/soql_sosl/sforce_api_calls_soql_relationships.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Parent-to-child subquery",
        "isCorrect": true
      },
      {
        "content": "Child-to-parent dot notation",
        "isCorrect": false
      },
      {
        "content": "SOSL",
        "isCorrect": false
      },
      {
        "content": "Aggregate query only",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "Which Apex method can return a map of all sObject types in the org? Choose 1 answer.",
    "codeSnippet": "// Get all sObject types in the org\nMap<String, Schema.SObjectType> globalDescribe = Schema.getGlobalDescribe();\n\n// Build a dynamic picklist of object names\nList<String> objectNames = new List<String>(globalDescribe.keySet());\nobjectNames.sort();\n// objectNames: ['Account', 'Case', 'Contact', 'Custom__c', ...]",
    "explanation": "Schema.getGlobalDescribe() returns Map<String, Schema.SObjectType> containing every object in the org. Use it to build dynamic UIs like object picklists. Schema.describeSObjects() takes a list of specific object names, not all. SObject.getDescribe() does not exist as a static method.",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_methods_system_schema.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Schema.getGlobalDescribe()",
        "isCorrect": true
      },
      {
        "content": "Schema.describeSObjects()",
        "isCorrect": false
      },
      {
        "content": "SObject.getDescribe()",
        "isCorrect": false
      },
      {
        "content": "Schema.getSObjects()",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "Which Apex method can retrieve all sObject tokens so a utility can build a dynamic picklist? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Schema.getGlobalDescribe() returns Map<String, Schema.SObjectType> containing every object in the org. Use it to build dynamic UIs like object picklists. Schema.describeSObjects() takes a list of specific object names, not all. SObject.getDescribe() does not exist as a static method.",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_methods_system_schema.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Schema.getGlobalDescribe()",
        "isCorrect": true
      },
      {
        "content": "Schema.describeSObjects()",
        "isCorrect": false
      },
      {
        "content": "SObject.getDescribe()",
        "isCorrect": false
      },
      {
        "content": "Schema.getSObjects()",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A developer needs a read-only field Total_Price__c that calculates Quantity__c * Unit_Price__c on every record. Which field type should be used? Choose 1 answer.",
    "codeSnippet": "/* Formula Field: Total_Price__c (Currency) */\nQuantity__c * Unit_Price__c\n\n/* Formula fields are read-only and recalculate\n   automatically whenever referenced fields change. */",
    "explanation": "\u2705 Formula fields calculate values dynamically at runtime, not storing data in the database. For Total_Price__c = Quantity__c * Unit_Price__c, a formula field provides real-time calculation without code or extra storage.\n\n\u274c Workflow/Flow would require triggers on every update to recalculate. Formula fields update automatically whenever any referenced field changes.\n\n\ud83d\udca1 Formula fields are read-only and don't count against data storage limits. Use them for derived values.",
    "referenceUrl": "https://trailhead.salesforce.com/en/content/learn/modules/customize-a-salesforce-object",
    "isPremium": false,
    "answers": [
      {
        "content": "Formula field",
        "isCorrect": true
      },
      {
        "content": "Roll-Up Summary field",
        "isCorrect": false
      },
      {
        "content": "Auto Number field",
        "isCorrect": false
      },
      {
        "content": "Lookup field",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "data-modeling-management",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A developer needs a read-only field Commission__c that calculates Amount__c * Commission_Rate__c on every record. Which field type should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "\u2705 Formula fields like Commission__c = Amount__c * Commission_Rate__c evaluate in real-time based on current field values. They're perfect for business calculations that should always reflect the latest data.\n\n\u274c A custom field updated by a trigger would store a snapshot in time, becoming stale if Amount or Rate changes later.\n\n\ud83d\udca1 Formula fields support arithmetic, logical, text, and date functions\u2014check the formula function reference for 100+ options.",
    "referenceUrl": "https://trailhead.salesforce.com/en/content/learn/modules/customize-a-salesforce-object",
    "isPremium": false,
    "answers": [
      {
        "content": "Formula field",
        "isCorrect": true
      },
      {
        "content": "Roll-Up Summary field",
        "isCorrect": false
      },
      {
        "content": "Auto Number field",
        "isCorrect": false
      },
      {
        "content": "Lookup field",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "When a Opportunity record's Stage changes to Closed Won, a Commission__c record should be created automatically. No complex logic is required. Which tool should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Record-triggered flows are the recommended declarative tool for automating actions when data changes. They replace workflow rules and Process Builder (both retired). Validation rules prevent saves but cannot create records. Approval processes require user action. Data Loader is for bulk imports, not automation.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/record-triggered-flows/get-started-with-triggered-flows",
    "isPremium": false,
    "answers": [
      {
        "content": "Record-triggered flow",
        "isCorrect": true
      },
      {
        "content": "Validation rule",
        "isCorrect": false
      },
      {
        "content": "Approval process",
        "isCorrect": false
      },
      {
        "content": "Data Loader",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "When a Account record's Type changes to Customer, a Onboarding__c record should be created automatically. No complex logic is required. Which tool should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Record-triggered flows are the recommended declarative tool for automating actions when data changes. They replace workflow rules and Process Builder (both retired). Validation rules prevent saves but cannot create records. Approval processes require user action. Data Loader is for bulk imports, not automation.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/record-triggered-flows/get-started-with-triggered-flows",
    "isPremium": false,
    "answers": [
      {
        "content": "Record-triggered flow",
        "isCorrect": true
      },
      {
        "content": "Validation rule",
        "isCorrect": false
      },
      {
        "content": "Approval process",
        "isCorrect": false
      },
      {
        "content": "Data Loader",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "An admin needs to create weekly Timesheet_Summary__c records every Friday night. Which automation should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Schedule-triggered flows run on a defined schedule (daily, weekly, etc.) without user interaction. They can query records and perform actions on them. Record-triggered flows only fire on data changes, not on a schedule. Screen flows require user input. Workflow rules are being retired.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/autolaunched-scheduled-flows/get-started-with-autolaunched-flows",
    "isPremium": false,
    "answers": [
      {
        "content": "Schedule-triggered flow",
        "isCorrect": true
      },
      {
        "content": "Record-triggered flow",
        "isCorrect": false
      },
      {
        "content": "Screen flow",
        "isCorrect": false
      },
      {
        "content": "Workflow rule",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "An admin needs to recalculate Account_Score__c nightly. Which automation should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Schedule-triggered flows run on a defined schedule (daily, weekly, etc.) without user interaction. They can query records and perform actions on them. Record-triggered flows only fire on data changes, not on a schedule. Screen flows require user input. Workflow rules are being retired.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/autolaunched-scheduled-flows/get-started-with-autolaunched-flows",
    "isPremium": false,
    "answers": [
      {
        "content": "Schedule-triggered flow",
        "isCorrect": true
      },
      {
        "content": "Record-triggered flow",
        "isCorrect": false
      },
      {
        "content": "Screen flow",
        "isCorrect": false
      },
      {
        "content": "Workflow rule",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "The business needs to prevent a Opportunity from being saved when Close Date is blank and Stage = Closed Won. Which tool should be used? Choose 1 answer.",
    "codeSnippet": "/* Validation Rule: Require_CloseDate_When_ClosedWon */\nAND(\n  ISPICKVAL(StageName, 'Closed Won'),\n  ISBLANK(CloseDate)\n)\n/* Error Message: Close Date is required when Stage is Closed Won. */",
    "explanation": "\u2705 Validation rules enforce data quality by preventing record saves that don't meet criteria. They run before records are saved to the database, showing error messages to users. Validation rules can reference fields, user info, and formula functions.\n\n\u274c Workflow rules run after save and can't prevent bad data. Triggers can validate, but validation rules are declarative and easier to maintain. Process Builder flows run after save.\n\n\ud83d\udca1 Exam tip: Validation rules fire on insert AND update. Use ISNEW() function to only validate on insert, or ISCHANGED() to validate only when a field changes.",
    "referenceUrl": "https://trailhead.salesforce.com/en/content/learn/modules/customize-a-salesforce-object",
    "isPremium": false,
    "answers": [
      {
        "content": "Validation rule",
        "isCorrect": true
      },
      {
        "content": "Record-triggered flow",
        "isCorrect": false
      },
      {
        "content": "Approval process",
        "isCorrect": false
      },
      {
        "content": "Apex trigger",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "The business needs to prevent a Expense__c from being saved when Amount__c is blank and Status = Submitted. Which tool should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "\u2705 Validation rules enforce data quality by preventing record saves that don't meet criteria. They run before records are saved to the database, showing error messages to users. Validation rules can reference fields, user info, and formula functions.\n\n\u274c Workflow rules run after save and can't prevent bad data. Triggers can validate, but validation rules are declarative and easier to maintain. Process Builder flows run after save.\n\n\ud83d\udca1 Exam tip: Validation rules fire on insert AND update. Use ISNEW() function to only validate on insert, or ISCHANGED() to validate only when a field changes.",
    "referenceUrl": "https://trailhead.salesforce.com/en/content/learn/modules/customize-a-salesforce-object",
    "isPremium": false,
    "answers": [
      {
        "content": "Validation rule",
        "isCorrect": true
      },
      {
        "content": "Record-triggered flow",
        "isCorrect": false
      },
      {
        "content": "Approval process",
        "isCorrect": false
      },
      {
        "content": "Apex trigger",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "The business needs to prevent a Project__c from being saved when Budget__c is blank and Status = Approved. Which tool should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "\u2705 Validation rules enforce data quality by preventing record saves that don't meet criteria. They run before records are saved to the database, showing error messages to users. Validation rules can reference fields, user info, and formula functions.\n\n\u274c Workflow rules run after save and can't prevent bad data. Triggers can validate, but validation rules are declarative and easier to maintain. Process Builder flows run after save.\n\n\ud83d\udca1 Exam tip: Validation rules fire on insert AND update. Use ISNEW() function to only validate on insert, or ISCHANGED() to validate only when a field changes.",
    "referenceUrl": "https://trailhead.salesforce.com/en/content/learn/modules/customize-a-salesforce-object",
    "isPremium": false,
    "answers": [
      {
        "content": "Validation rule",
        "isCorrect": true
      },
      {
        "content": "Record-triggered flow",
        "isCorrect": false
      },
      {
        "content": "Approval process",
        "isCorrect": false
      },
      {
        "content": "Apex trigger",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "When a Case is inserted, set Status to 'New' if it is blank. What is the best approach? Choose 1 answer.",
    "codeSnippet": "// Before-insert trigger example\ntrigger OpportunityTrigger on Opportunity (before insert) {\n    for (Opportunity opp : Trigger.new) {\n        // Set default values before insert\n        if (opp.Probability == null) {\n            if (opp.StageName == 'Prospecting') {\n                opp.Probability = 10;\n            } else if (opp.StageName == 'Qualification') {\n                opp.Probability = 25;\n            }\n        }\n    }\n}",
    "explanation": "Before-insert triggers modify records in Trigger.new before they are saved to the database -- no extra DML needed. After-insert triggers would require a separate update DML statement, consuming an additional DML operation against governor limits. Batch Apex is for large-volume processing, not field defaults.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/apex_triggers",
    "isPremium": false,
    "answers": [
      {
        "content": "Before-insert Apex trigger",
        "isCorrect": true
      },
      {
        "content": "After-insert Apex trigger with an extra update DML",
        "isCorrect": false
      },
      {
        "content": "Batch Apex",
        "isCorrect": false
      },
      {
        "content": "Approval process",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "When a Ticket__c is inserted, set Priority__c to 'Medium' if it is blank. What is the best approach? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Before-insert triggers modify records in Trigger.new before they are saved to the database -- no extra DML needed. After-insert triggers would require a separate update DML statement, consuming an additional DML operation against governor limits. Batch Apex is for large-volume processing, not field defaults.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/apex_triggers",
    "isPremium": false,
    "answers": [
      {
        "content": "Before-insert Apex trigger",
        "isCorrect": true
      },
      {
        "content": "After-insert Apex trigger with an extra update DML",
        "isCorrect": false
      },
      {
        "content": "Batch Apex",
        "isCorrect": false
      },
      {
        "content": "Approval process",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 4,
    "content": "A nightly job must recalculate discounts across 2 million Order__c records. Which asynchronous mechanism is the best fit? Choose 1 answer.",
    "codeSnippet": "public class OrderDiscountBatch implements Database.Batchable<SObject> {\n    public Database.QueryLocator start(Database.BatchableContext bc) {\n        return Database.getQueryLocator(\n            'SELECT Id, Amount__c, Discount__c FROM Order__c'\n        );\n    }\n    public void execute(Database.BatchableContext bc, List<Order__c> scope) {\n        for (Order__c o : scope) {\n            o.Discount__c = o.Amount__c > 10000 ? 0.15 : 0.05;\n        }\n        update scope;\n    }\n    public void finish(Database.BatchableContext bc) {\n        System.debug('Batch complete: ' + bc.getJobId());\n    }\n}\n// Schedule nightly: Database.executeBatch(new OrderDiscountBatch(), 200);",
    "explanation": "Batch Apex processes millions of records by splitting work into chunks (default 200 per execute()). Each chunk gets its own governor limits. Future methods cannot handle this volume (limited to 50 calls per transaction). Queueable Apex handles one job at a time, not millions of records. Scheduled flows have a 250,000 record limit.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/asynchronous_apex",
    "isPremium": false,
    "answers": [
      {
        "content": "Batch Apex",
        "isCorrect": true
      },
      {
        "content": "Future method",
        "isCorrect": false
      },
      {
        "content": "Queueable Apex",
        "isCorrect": false
      },
      {
        "content": "Scheduled flow",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 4,
    "content": "A nightly job must close stale cases across 900,000 Case records. Which async mechanism is the best fit? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Batch Apex processes millions of records by splitting work into chunks (default 200 per execute()). Each chunk gets its own governor limits. Future methods cannot handle this volume (limited to 50 calls per transaction). Queueable Apex handles one job at a time, not millions of records. Scheduled flows have a 250,000 record limit.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/asynchronous_apex",
    "isPremium": false,
    "answers": [
      {
        "content": "Batch Apex",
        "isCorrect": true
      },
      {
        "content": "Future method",
        "isCorrect": false
      },
      {
        "content": "Queueable Apex",
        "isCorrect": false
      },
      {
        "content": "Scheduled flow",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 4,
    "content": "After Order__c records are inserted, the system must call a shipping API and then chain another job to update related records. Which async approach should be used? Choose 1 answer.",
    "codeSnippet": "public class ShippingQueueable implements Queueable, Database.AllowsCallouts {\n    private List<Id> orderIds;\n    public ShippingQueueable(List<Id> ids) { this.orderIds = ids; }\n\n    public void execute(QueueableContext ctx) {\n        // Make callout to shipping API\n        HttpResponse res = ShippingService.createShipment(orderIds);\n        // Chain next job to update related records\n        System.enqueueJob(new UpdateRelatedRecordsJob(orderIds));\n    }\n}\n// Enqueue from trigger: System.enqueueJob(new ShippingQueueable(orderIds));",
    "explanation": "Queueable Apex is the best choice when you need callouts AND job chaining. It accepts complex types (unlike @future which only takes primitives) and can chain another Queueable job via System.enqueueJob(). Future methods cannot chain. Scheduled Apex runs on a schedule, not in response to data events.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/asynchronous_apex",
    "isPremium": false,
    "answers": [
      {
        "content": "Queueable Apex",
        "isCorrect": true
      },
      {
        "content": "Future method",
        "isCorrect": false
      },
      {
        "content": "Scheduled Apex",
        "isCorrect": false
      },
      {
        "content": "Workflow rule",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 4,
    "content": "After Case records are inserted, the system must call a ticketing system and then chain another job to update related records. Which async approach should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Queueable Apex is the best choice when you need callouts AND job chaining. It accepts complex types (unlike @future which only takes primitives) and can chain another Queueable job via System.enqueueJob(). Future methods cannot chain. Scheduled Apex runs on a schedule, not in response to data events.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/asynchronous_apex",
    "isPremium": false,
    "answers": [
      {
        "content": "Queueable Apex",
        "isCorrect": true
      },
      {
        "content": "Future method",
        "isCorrect": false
      },
      {
        "content": "Scheduled Apex",
        "isCorrect": false
      },
      {
        "content": "Workflow rule",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "MULTIPLE_CHOICE",
    "difficulty": 3,
    "content": "A developer wants to publish the Order_Placed__e platform event when an order is created. Which two items are required in Salesforce to do this? Choose 2 answers.",
    "codeSnippet": "// Publishing a platform event from Apex\nOrder_Placed__e event = new Order_Placed__e(\n    Order_Id__c = order.Id,\n    Amount__c = order.Total__c\n);\nDatabase.SaveResult sr = EventBus.publish(event);",
    "explanation": "Platform events require two things: (1) define the event with custom fields in Setup, and (2) publish it from Apex using EventBus.publish() or from a Flow using a Create Records element. Subscribers (triggers, flows, or external systems via CometD) then react to published events. Platform events are not sObjects -- you cannot create validation rules on them.",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.platform_events.meta/platform_events/platform_events_intro.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Define a platform event with custom fields",
        "isCorrect": true
      },
      {
        "content": "Publish the event from Apex or Flow",
        "isCorrect": true
      },
      {
        "content": "Create a validation rule on the event object",
        "isCorrect": false
      },
      {
        "content": "Use a workflow rule to send an outbound message",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "MULTIPLE_CHOICE",
    "difficulty": 3,
    "content": "A developer wants to publish the Inventory_Low__e platform event when inventory drops below threshold. Which two items are required in Salesforce to do this? Choose 2 answers.",
    "codeSnippet": null,
    "explanation": "Platform events need: (1) the event definition with custom fields created in Setup, and (2) a publishing mechanism -- either Apex code using EventBus.publish() or a Flow with a Create Records element. Unlike standard/custom objects, platform events do not support validation rules, workflow rules, or approval processes.",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.platform_events.meta/platform_events/platform_events_intro.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Define a platform event with custom fields",
        "isCorrect": true
      },
      {
        "content": "Publish the event from Apex or Flow",
        "isCorrect": true
      },
      {
        "content": "Create a validation rule on the event object",
        "isCorrect": false
      },
      {
        "content": "Use a workflow rule to send an outbound message",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A list of Account IDs contains duplicates and must be de-duplicated before a query. Which collection type should be used? Choose 1 answer.",
    "codeSnippet": "// Deduplicate IDs using a Set\nList<Id> duplicateIds = new List<Id>{'001xx1', '001xx2', '001xx1'};\nSet<Id> uniqueIds = new Set<Id>(duplicateIds);\n// uniqueIds now contains only 2 IDs\n\n// Use directly in SOQL\nList<Account> accounts = [\n    SELECT Id, Name FROM Account WHERE Id IN :uniqueIds\n];",
    "explanation": "Set<Id> automatically enforces uniqueness -- adding a duplicate Id is silently ignored. Lists allow duplicates and would require manual dedup logic. Maps store key-value pairs (useful for lookups, but overkill for simple dedup). Sets can also be used directly in SOQL WHERE clauses: WHERE Id IN :mySet.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/apex_database/apex_database_dml",
    "isPremium": false,
    "answers": [
      {
        "content": "Set<Id>",
        "isCorrect": true
      },
      {
        "content": "List<Id>",
        "isCorrect": false
      },
      {
        "content": "Map<Id, Id>",
        "isCorrect": false
      },
      {
        "content": "Queueable",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A list of Case IDs contains duplicates and must be de-duplicated before a query. Which collection type should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Set<Id> automatically enforces uniqueness -- adding a duplicate Id is silently ignored. Lists allow duplicates and would require manual dedup logic. Maps store key-value pairs (useful for lookups, but overkill for simple dedup). Sets can also be used directly in SOQL WHERE clauses: WHERE Id IN :mySet.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/apex_database/apex_database_dml",
    "isPremium": false,
    "answers": [
      {
        "content": "Set<Id>",
        "isCorrect": true
      },
      {
        "content": "List<Id>",
        "isCorrect": false
      },
      {
        "content": "Map<Id, Id>",
        "isCorrect": false
      },
      {
        "content": "Queueable",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A trigger processes up to 200 Opportunity records at once. Which practice helps avoid governor limits? Choose 1 answer.",
    "codeSnippet": "// BAD: DML inside loop - hits governor limit at 150 DML statements\nfor (Opportunity opp : Trigger.new) {\n    Task t = new Task(WhatId = opp.Id, Subject = 'Follow up');\n    insert t; // DML per record!\n}\n\n// GOOD: Bulkified - one DML for all records\nList<Task> tasks = new List<Task>();\nfor (Opportunity opp : Trigger.new) {\n    tasks.add(new Task(WhatId = opp.Id, Subject = 'Follow up'));\n}\ninsert tasks; // Single DML statement",
    "explanation": "Bulkification means collecting records into a list and performing one DML operation outside the loop. Salesforce limits you to 150 DML statements per transaction, so inserting inside a loop fails at 150 records. A single bulk DML handles up to 10,000 records.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/apex_triggers/apex_triggers_bulk",
    "isPremium": false,
    "answers": [
      {
        "content": "Accumulate records in a list and perform a single DML statement",
        "isCorrect": true
      },
      {
        "content": "Perform DML inside the for loop",
        "isCorrect": false
      },
      {
        "content": "Use System.debug for each record",
        "isCorrect": false
      },
      {
        "content": "Use a validation rule instead",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A trigger processes up to 200 Account records at once. Which practice helps avoid governor limits? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Bulkification means processing all records as a collection with one DML statement outside the loop, rather than one DML per record inside the loop. Salesforce allows only 150 DML statements per transaction. A trigger processing 200 records with DML in the loop would fail at record 151.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/apex_triggers/apex_triggers_bulk",
    "isPremium": false,
    "answers": [
      {
        "content": "Accumulate records in a list and perform a single DML statement",
        "isCorrect": true
      },
      {
        "content": "Perform DML inside the for loop",
        "isCorrect": false
      },
      {
        "content": "Use System.debug for each record",
        "isCorrect": false
      },
      {
        "content": "Use a validation rule instead",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "When a Case record is created, the system must send an email and update a field. No complex logic is required. Which tool should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Record-triggered flows handle simple automation declaratively -- no code needed. They run when a record is created, updated, or deleted and can update fields, send emails, create records, and post to Chatter. Use Apex triggers only when flow cannot meet the requirement (complex logic, callouts, cross-object transactions).",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/record-triggered-flows/get-started-with-triggered-flows",
    "isPremium": false,
    "answers": [
      {
        "content": "Record-triggered flow",
        "isCorrect": true
      },
      {
        "content": "Apex trigger",
        "isCorrect": false
      },
      {
        "content": "Scheduled Apex",
        "isCorrect": false
      },
      {
        "content": "Batch Apex",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "When a Opportunity record is created, the system must update a related Account field. No complex logic is required. Which tool should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "For simple automation (field updates, emails, record creation) without complex logic, record-triggered flows are preferred over Apex triggers. They are declarative, easier to maintain, and do not require test coverage. Use Apex triggers only when flows cannot meet the requirement (complex logic, callouts, or cross-object transactions).",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/record-triggered-flows/get-started-with-triggered-flows",
    "isPremium": false,
    "answers": [
      {
        "content": "Record-triggered flow",
        "isCorrect": true
      },
      {
        "content": "Apex trigger",
        "isCorrect": false
      },
      {
        "content": "Scheduled Apex",
        "isCorrect": false
      },
      {
        "content": "Batch Apex",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "What is the debug output of the code below when score is 92? Choose 1 answer.",
    "codeSnippet": "Integer score = 92;\nString grade;\nif (score >= 90) {\n    grade = 'A';\n} else if (score >= 80) {\n    grade = 'B';\n} else if (score >= 70) {\n    grade = 'C';\n} else if (score >= 60) {\n    grade = 'D';\n} else {\n    grade = 'F';\n}\nSystem.debug(grade);",
    "explanation": "In an if/else-if chain, Apex evaluates conditions top to bottom and executes only the first matching block. Once a condition is true, all subsequent else-if blocks are skipped. Order matters: putting the highest threshold first ensures correct grading.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/apex_database/apex_database_intro",
    "isPremium": false,
    "answers": [
      {
        "content": "A",
        "isCorrect": true
      },
      {
        "content": "B",
        "isCorrect": false
      },
      {
        "content": "C",
        "isCorrect": false
      },
      {
        "content": "D",
        "isCorrect": false
      },
      {
        "content": "F",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "process-automation-logic",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "What is the debug output of the code below when score is 75? Choose 1 answer.",
    "codeSnippet": "Integer score = 75;\nString grade;\nif (score >= 90) {\n    grade = 'A';\n} else if (score >= 80) {\n    grade = 'B';\n} else if (score >= 70) {\n    grade = 'C';\n} else if (score >= 60) {\n    grade = 'D';\n} else {\n    grade = 'F';\n}\nSystem.debug(grade);",
    "explanation": "In an if/else-if chain, Apex evaluates conditions top to bottom and executes only the first matching block. Once a condition is true, all subsequent else-if blocks are skipped. Order matters: putting the highest threshold first ensures correct grading.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/apex_database/apex_database_intro",
    "isPremium": false,
    "answers": [
      {
        "content": "A",
        "isCorrect": false
      },
      {
        "content": "B",
        "isCorrect": false
      },
      {
        "content": "C",
        "isCorrect": true
      },
      {
        "content": "D",
        "isCorrect": false
      },
      {
        "content": "F",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A developer created an outbound change set in a sandbox, but a sandbox change set can\u2019t be uploaded to production. What should be done to resolve this? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Before uploading a change set, the target org must enable the deployment connection in Setup > Deployment Settings by checking 'Allow Inbound Changes' for the source org. This is a security measure -- orgs must explicitly trust each other. Creating a new sandbox does not fix deployment permissions.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/flow-implementation-2/deploy-your-flow-to-production",
    "isPremium": false,
    "answers": [
      {
        "content": "Allow inbound changes on the Deployment Settings page in the target org",
        "isCorrect": true
      },
      {
        "content": "Create a new sandbox with full copy",
        "isCorrect": false
      },
      {
        "content": "Enable debug logs for the target org",
        "isCorrect": false
      },
      {
        "content": "Grant View All Data to the user",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A developer created an outbound change set in a sandbox, but an outbound change set can\u2019t be sent to the production org. What should be done to resolve this? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Before uploading a change set, the target org must enable the deployment connection in Setup > Deployment Settings by checking 'Allow Inbound Changes' for the source org. This is a security measure -- orgs must explicitly trust each other. Creating a new sandbox does not fix deployment permissions.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/flow-implementation-2/deploy-your-flow-to-production",
    "isPremium": false,
    "answers": [
      {
        "content": "Allow inbound changes on the Deployment Settings page in the target org",
        "isCorrect": true
      },
      {
        "content": "Create a new sandbox with full copy",
        "isCorrect": false
      },
      {
        "content": "Enable debug logs for the target org",
        "isCorrect": false
      },
      {
        "content": "Grant View All Data to the user",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "Why does Salesforce enforce governor limits in Apex? Choose 1 answer.",
    "codeSnippet": "// Bulkified trigger code (handles collections, not single records)\ntrigger AccountTrigger on Account (before insert, before update) {\n    // GOOD: Bulkified - handles all records in one query\n    Set<Id> ownerIds = new Set<Id>();\n    for (Account acc : Trigger.new) {\n        ownerIds.add(acc.OwnerId);\n    }\n\n    Map<Id, User> ownerMap = new Map<Id, User>([\n        SELECT Id, Name, Email\n        FROM User\n        WHERE Id IN :ownerIds\n    ]);\n\n    for (Account acc : Trigger.new) {\n        User owner = ownerMap.get(acc.OwnerId);\n        acc.Owner_Email__c = owner.Email;\n    }\n}\n\n// BAD: Non-bulkified (would hit governor limits)\n// for (Account acc : Trigger.new) {\n//     User owner = [SELECT Email FROM User WHERE Id = :acc.OwnerId];\n//     acc.Owner_Email__c = owner.Email;\n// }",
    "explanation": "Salesforce is a multi-tenant platform where all orgs share the same infrastructure. Governor limits (100 SOQL queries, 150 DML statements, 6MB heap, etc.) prevent any single org from consuming excessive CPU, memory, or database resources that would degrade performance for others.",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_gov_limits.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Prevent one org from monopolizing shared resources",
        "isCorrect": true
      },
      {
        "content": "Increase the number of API calls per user",
        "isCorrect": false
      },
      {
        "content": "Allow unlimited CPU time for triggers",
        "isCorrect": false
      },
      {
        "content": "Disable validations during deployments",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "Governor limits primarily exist to ensure what? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Salesforce is a multi-tenant platform where all orgs share the same infrastructure. Governor limits (100 SOQL queries, 150 DML statements, 6MB heap, etc.) prevent any single org from consuming excessive CPU, memory, or database resources that would degrade performance for others.",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_gov_limits.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Prevent one org from monopolizing shared resources",
        "isCorrect": true
      },
      {
        "content": "Increase the number of API calls per user",
        "isCorrect": false
      },
      {
        "content": "Allow unlimited CPU time for triggers",
        "isCorrect": false
      },
      {
        "content": "Disable validations during deployments",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "Which practice helps Apex trigger code handle bulk data and avoid governor limits? Choose 1 answer.",
    "codeSnippet": "// SOQL FOR loop - memory efficient for large result sets\n// Prevents heap size limit by processing in chunks\nfor (List<Account> accountBatch : [\n    SELECT Id, Name, AnnualRevenue\n    FROM Account\n    WHERE AnnualRevenue > 1000000\n]) {\n    // Process each batch (up to 200 records per batch)\n    for (Account acc : accountBatch) {\n        acc.Description = 'High Revenue';\n    }\n    update accountBatch;\n}\n\n// Avoids this (heap size error on 10,000+ records):\n// List<Account> allAccounts = [SELECT Id FROM Account]; // Loads all into memory",
    "explanation": "Bulkification means collecting IDs in a Set, performing one SOQL query with WHERE Id IN :idSet, and one DML statement for all records. SOQL inside a loop hits the 100-query limit. DML inside a loop hits the 150-DML limit. System.debug per record wastes CPU time but does not directly cause governor limit failures.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/apex_triggers/apex_triggers_bulk",
    "isPremium": false,
    "answers": [
      {
        "content": "Use collections and a single DML statement",
        "isCorrect": true
      },
      {
        "content": "Execute SOQL inside a loop",
        "isCorrect": false
      },
      {
        "content": "Call System.debug for every record",
        "isCorrect": false
      },
      {
        "content": "Use a separate DML statement per record",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "Which practice helps Apex batch code handle bulk data and avoid governor limits? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Bulkification means collecting IDs in a Set, performing one SOQL query with WHERE Id IN :idSet, and one DML statement for all records. SOQL inside a loop hits the 100-query limit. DML inside a loop hits the 150-DML limit. System.debug per record wastes CPU time but does not directly cause governor limit failures.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/apex_triggers/apex_triggers_bulk",
    "isPremium": false,
    "answers": [
      {
        "content": "Use collections and a single DML statement",
        "isCorrect": true
      },
      {
        "content": "Execute SOQL inside a loop",
        "isCorrect": false
      },
      {
        "content": "Call System.debug for every record",
        "isCorrect": false
      },
      {
        "content": "Use a separate DML statement per record",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "In Visualforce development, which option best maps Salesforce features to the MVC design pattern? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "In Salesforce MVC: Model = standard/custom objects (data layer), View = Visualforce pages, Lightning components (presentation), Controller = standard controllers, custom Apex controllers (business logic). JavaScript is not the model, and SOQL is a query language, not a controller.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/platform_dev_basics/platform_dev_basics_code",
    "isPremium": false,
    "answers": [
      {
        "content": "Model: Standard and Custom Objects; View: Pages and Components; Controller: Standard and Custom Controllers",
        "isCorrect": true
      },
      {
        "content": "Model: JavaScript; View: Apex; Controller: Objects",
        "isCorrect": false
      },
      {
        "content": "Model: Controllers; View: Objects; Controller: Pages",
        "isCorrect": false
      },
      {
        "content": "Model: Visualforce; View: Apex; Controller: SOQL",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "In Salesforce UI architecture, which option best maps Salesforce features to the MVC design pattern? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "In Salesforce MVC: Model = standard/custom objects (data layer), View = Visualforce pages, Lightning components (presentation), Controller = standard controllers, custom Apex controllers (business logic). JavaScript is not the model, and SOQL is a query language, not a controller.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/platform_dev_basics/platform_dev_basics_code",
    "isPremium": false,
    "answers": [
      {
        "content": "Model: Standard and Custom Objects; View: Pages and Components; Controller: Standard and Custom Controllers",
        "isCorrect": true
      },
      {
        "content": "Model: JavaScript; View: Apex; Controller: Objects",
        "isCorrect": false
      },
      {
        "content": "Model: Controllers; View: Objects; Controller: Pages",
        "isCorrect": false
      },
      {
        "content": "Model: Visualforce; View: Apex; Controller: SOQL",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "When writing an Apex service class, how can a developer enforce record-level sharing rules? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Declaring a class 'with sharing' enforces the running user's sharing rules, role hierarchy, and manual shares. 'without sharing' bypasses record-level security (useful for system operations). @AuraEnabled controls LWC access to Apex methods, not sharing. Validation rules enforce data quality, not record access.",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_classes_keywords_sharing.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Declare the class with 'with sharing'",
        "isCorrect": true
      },
      {
        "content": "Use 'without sharing'",
        "isCorrect": false
      },
      {
        "content": "Use @AuraEnabled(cacheable=true)",
        "isCorrect": false
      },
      {
        "content": "Use a validation rule",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "When writing an Apex trigger handler, how can a developer enforce record-level sharing rules? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Declaring a class 'with sharing' enforces the running user's sharing rules, role hierarchy, and manual shares. 'without sharing' bypasses record-level security (useful for system operations). @AuraEnabled controls LWC access to Apex methods, not sharing. Validation rules enforce data quality, not record access.",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_classes_keywords_sharing.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Declare the class with 'with sharing'",
        "isCorrect": true
      },
      {
        "content": "Use 'without sharing'",
        "isCorrect": false
      },
      {
        "content": "Use @AuraEnabled(cacheable=true)",
        "isCorrect": false
      },
      {
        "content": "Use a validation rule",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "Users need to grant Export Reports without changing their profile. What should an admin use? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Permission sets extend a user's access beyond their profile without modifying the profile itself. Multiple permission sets can be assigned to one user. Creating a new profile per user is not scalable. Role hierarchy controls record visibility, not system permissions. Sharing rules control record access, not feature permissions.",
    "referenceUrl": "https://help.salesforce.com/s/articleView?id=sf.perm_sets_overview.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Permission set",
        "isCorrect": true
      },
      {
        "content": "New profile for each user",
        "isCorrect": false
      },
      {
        "content": "Role hierarchy",
        "isCorrect": false
      },
      {
        "content": "Sharing rule",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "Users need to grant View All on Cases without changing their profile. What should an admin use? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Permission sets extend a user's access beyond their profile without modifying the profile itself. Multiple permission sets can be assigned to one user. Creating a new profile per user is not scalable. Role hierarchy controls record visibility, not system permissions. Sharing rules control record access, not feature permissions.",
    "referenceUrl": "https://help.salesforce.com/s/articleView?id=sf.perm_sets_overview.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Permission set",
        "isCorrect": true
      },
      {
        "content": "New profile for each user",
        "isCorrect": false
      },
      {
        "content": "Role hierarchy",
        "isCorrect": false
      },
      {
        "content": "Sharing rule",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "MULTIPLE_CHOICE",
    "difficulty": 2,
    "content": "While troubleshooting an Apex trigger, which two debug log categories can be configured for logging levels? Choose 2 answers.",
    "codeSnippet": null,
    "explanation": "Debug log categories include: Apex Code, Visualforce, Database, Workflow, Validation, Callout, and System. Each category can be set to a level (NONE through FINEST). 'Reports' and 'Lightning Components' are not debug log categories. LWC debugging uses browser DevTools, not server-side debug logs.",
    "referenceUrl": "https://help.salesforce.com/s/articleView?id=sf.code_debug_log_categories.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Apex Code",
        "isCorrect": true
      },
      {
        "content": "Visualforce",
        "isCorrect": true
      },
      {
        "content": "Reports",
        "isCorrect": false
      },
      {
        "content": "Lightning Components",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "MULTIPLE_CHOICE",
    "difficulty": 2,
    "content": "While diagnosing a workflow issue, which two debug log categories can be configured for logging levels? Choose 2 answers.",
    "codeSnippet": null,
    "explanation": "Debug log categories include: Apex Code, Visualforce, Database, Workflow, Validation, Callout, and System. Each category can be set to a level (NONE through FINEST). 'Reports' and 'Lightning Components' are not debug log categories. LWC debugging uses browser DevTools, not server-side debug logs.",
    "referenceUrl": "https://help.salesforce.com/s/articleView?id=sf.code_debug_log_categories.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Apex Code",
        "isCorrect": true
      },
      {
        "content": "Visualforce",
        "isCorrect": true
      },
      {
        "content": "Reports",
        "isCorrect": false
      },
      {
        "content": "Lightning Components",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "MULTIPLE_CHOICE",
    "difficulty": 3,
    "content": "During a production deployment, which two statements are true about Apex tests? Choose 2 answers.",
    "codeSnippet": null,
    "explanation": "Production deployments have two strict requirements: (1) overall org-wide Apex code coverage must be at least 75%, and (2) every test method must pass with no failures. Test methods cannot access org data by default -- use @IsTest(SeeAllData=true) to opt in, which is generally discouraged. Change set deployments run all local tests by default.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/apex_testing",
    "isPremium": false,
    "answers": [
      {
        "content": "Overall Apex code coverage must be at least 75%",
        "isCorrect": true
      },
      {
        "content": "All tests must pass for the deployment to succeed",
        "isCorrect": true
      },
      {
        "content": "Test methods can access production data by default",
        "isCorrect": false
      },
      {
        "content": "Only specified tests run for change set deployments",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "MULTIPLE_CHOICE",
    "difficulty": 3,
    "content": "When deploying Apex classes to production, which two statements are true about Apex tests? Choose 2 answers.",
    "codeSnippet": null,
    "explanation": "Production deployments have two strict requirements: (1) overall org-wide Apex code coverage must be at least 75%, and (2) every test method must pass with no failures. Test methods cannot access org data by default -- use @IsTest(SeeAllData=true) to opt in, which is generally discouraged. Change set deployments run all local tests by default.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/apex_testing",
    "isPremium": false,
    "answers": [
      {
        "content": "Overall Apex code coverage must be at least 75%",
        "isCorrect": true
      },
      {
        "content": "All tests must pass for the deployment to succeed",
        "isCorrect": true
      },
      {
        "content": "Test methods can access production data by default",
        "isCorrect": false
      },
      {
        "content": "Only specified tests run for change set deployments",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "Which tool is the built-in way to move metadata between related orgs? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Change sets are Salesforce's built-in tool for moving metadata (custom objects, fields, flows, Apex classes) between related orgs (e.g., sandbox to production). Data Import Wizard moves data, not metadata. Reports display data. Schema Builder designs the data model but does not deploy it.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/flow-implementation-2/deploy-your-flow-to-production",
    "isPremium": false,
    "answers": [
      {
        "content": "Change Sets",
        "isCorrect": true
      },
      {
        "content": "Data Import Wizard",
        "isCorrect": false
      },
      {
        "content": "Reports",
        "isCorrect": false
      },
      {
        "content": "Schema Builder",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "Which tool is the built-in way to move custom object changes between a sandbox and its production org? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Change sets are Salesforce's built-in tool for moving metadata (custom objects, fields, flows, Apex classes) between related orgs (e.g., sandbox to production). Data Import Wizard moves data, not metadata. Reports display data. Schema Builder designs the data model but does not deploy it.",
    "referenceUrl": "https://trailhead.salesforce.com/content/learn/modules/flow-implementation-2/deploy-your-flow-to-production",
    "isPremium": false,
    "answers": [
      {
        "content": "Change Sets",
        "isCorrect": true
      },
      {
        "content": "Data Import Wizard",
        "isCorrect": false
      },
      {
        "content": "Reports",
        "isCorrect": false
      },
      {
        "content": "Schema Builder",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 1,
    "content": "Why should a developer use a sandbox to test new automation instead of production? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Sandboxes are copies of your production org where you can safely develop and test without affecting live users or data. They do NOT provide unlimited governor limits (same limits as production). Changes must be explicitly deployed -- they never auto-deploy. Security controls still apply in sandboxes.",
    "referenceUrl": "https://help.salesforce.com/s/articleView?id=sf.deploy_sandboxes_intro.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "It isolates development and testing from production data and users",
        "isCorrect": true
      },
      {
        "content": "It provides unlimited governor limits",
        "isCorrect": false
      },
      {
        "content": "It automatically deploys changes to production",
        "isCorrect": false
      },
      {
        "content": "It bypasses security controls",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 1,
    "content": "Why should a developer use a sandbox to run regression tests instead of production? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Sandboxes are copies of your production org where you can safely develop and test without affecting live users or data. They do NOT provide unlimited governor limits (same limits as production). Changes must be explicitly deployed -- they never auto-deploy. Security controls still apply in sandboxes.",
    "referenceUrl": "https://help.salesforce.com/s/articleView?id=sf.deploy_sandboxes_intro.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "It isolates development and testing from production data and users",
        "isCorrect": true
      },
      {
        "content": "It provides unlimited governor limits",
        "isCorrect": false
      },
      {
        "content": "It automatically deploys changes to production",
        "isCorrect": false
      },
      {
        "content": "It bypasses security controls",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 1,
    "content": "Why should a developer use a sandbox to try a new integration instead of production? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Sandboxes are copies of your production org where you can safely develop and test without affecting live users or data. They do NOT provide unlimited governor limits (same limits as production). Changes must be explicitly deployed -- they never auto-deploy. Security controls still apply in sandboxes.",
    "referenceUrl": "https://help.salesforce.com/s/articleView?id=sf.deploy_sandboxes_intro.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "It isolates development and testing from production data and users",
        "isCorrect": true
      },
      {
        "content": "It provides unlimited governor limits",
        "isCorrect": false
      },
      {
        "content": "It automatically deploys changes to production",
        "isCorrect": false
      },
      {
        "content": "It bypasses security controls",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "Before updating Account.AnnualRevenue in Apex, how can a developer check field-level security? Choose 1 answer.",
    "codeSnippet": "// Check FLS before updating a field\nSchema.DescribeFieldResult dfr = Account.AnnualRevenue.getDescribe();\nif (dfr.isUpdateable()) {\n    acc.AnnualRevenue = 5000000;\n    update acc;\n} else {\n    throw new SecurityException('Insufficient field access');\n}",
    "explanation": "DescribeFieldResult.isUpdateable() checks field-level security (FLS) to verify the running user has edit access to a specific field. Always check FLS before DML in Apex to prevent unauthorized data changes. isQueryable() checks object-level access, not field-level. @future is for async processing. System.isBatch() checks execution context.",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_classes_perms_enforcing.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Use DescribeFieldResult.isUpdateable()",
        "isCorrect": true
      },
      {
        "content": "Use DescribeSObjectResult.isQueryable()",
        "isCorrect": false
      },
      {
        "content": "Use @future(callout=true)",
        "isCorrect": false
      },
      {
        "content": "Use System.isBatch()",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "salesforce-fundamentals",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "Before updating Contact.Email in Apex, how can a developer check field-level security? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "DescribeFieldResult.isUpdateable() checks field-level security (FLS) to verify the running user has edit access to a specific field. Always check FLS before DML in Apex to prevent unauthorized data changes. isQueryable() checks object-level access, not field-level. @future is for async processing. System.isBatch() checks execution context.",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_classes_perms_enforcing.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Use DescribeFieldResult.isUpdateable()",
        "isCorrect": true
      },
      {
        "content": "Use DescribeSObjectResult.isQueryable()",
        "isCorrect": false
      },
      {
        "content": "Use @future(callout=true)",
        "isCorrect": false
      },
      {
        "content": "Use System.isBatch()",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A developer needs to build a new Lightning Experience page. Which framework is recommended for new development? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Lightning Web Components (LWC) is Salesforce's modern UI framework built on web standards (Web Components, ES modules). It replaced Aura as the recommended framework. Visualforce is legacy (server-rendered HTML). S-Controls were deprecated years ago. LWC components can coexist with Aura but not vice versa.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "Lightning Web Components",
        "isCorrect": true
      },
      {
        "content": "Aura Components",
        "isCorrect": false
      },
      {
        "content": "Visualforce",
        "isCorrect": false
      },
      {
        "content": "S-control",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A developer needs to build a modern UI for Salesforce mobile. Which framework is recommended for new development? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Lightning Web Components (LWC) is Salesforce's modern UI framework built on web standards (Web Components, ES modules). It replaced Aura as the recommended framework. Visualforce is legacy (server-rendered HTML). S-Controls were deprecated years ago. LWC components can coexist with Aura but not vice versa.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "Lightning Web Components",
        "isCorrect": true
      },
      {
        "content": "Aura Components",
        "isCorrect": false
      },
      {
        "content": "Visualforce",
        "isCorrect": false
      },
      {
        "content": "S-control",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A developer needs to generate a PDF invoice from Salesforce. Which technology is best suited? Choose 1 answer.",
    "codeSnippet": "<apex:page standardController=\"Invoice__c\" renderAs=\"pdf\">\n  <h1>Invoice #{!Invoice__c.Name}</h1>\n  <p>Date: {!Invoice__c.Invoice_Date__c}</p>\n  <p>Amount: {!Invoice__c.Total__c}</p>\n</apex:page>",
    "explanation": "Visualforce pages support renderAs=\"pdf\" to generate downloadable PDFs directly from Salesforce data. LWC cannot render PDFs natively. This is one of the few cases where Visualforce is still the recommended approach over LWC.",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.pages.meta/pages/pages_output_pdf_renderas.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Visualforce page rendered as PDF",
        "isCorrect": true
      },
      {
        "content": "Lightning Web Component",
        "isCorrect": false
      },
      {
        "content": "Flow Builder screen flow",
        "isCorrect": false
      },
      {
        "content": "Schema Builder",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A developer needs to render a PDF quote from Salesforce. Which technology is best suited? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Visualforce pages support renderAs=\"pdf\" to convert server-rendered HTML into downloadable PDFs. LWC runs client-side and cannot generate PDFs natively. This is one of the remaining use cases where Visualforce is still preferred over LWC.",
    "referenceUrl": "https://developer.salesforce.com/docs/atlas.en-us.pages.meta/pages/pages_output_pdf_renderas.htm",
    "isPremium": false,
    "answers": [
      {
        "content": "Visualforce page rendered as PDF",
        "isCorrect": true
      },
      {
        "content": "Lightning Web Component",
        "isCorrect": false
      },
      {
        "content": "Flow Builder screen flow",
        "isCorrect": false
      },
      {
        "content": "Schema Builder",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A parent component needs to pass the value 'recordId' into a child Lightning Web Component. Which decorator should be used on the child property? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "\u2705 The @api decorator makes a property public and reactive in Lightning Web Components. When the parent component sets recordId, the child component's @api recordId property automatically receives and reacts to changes.\n\n\u274c Without @api, the property is private to the component. Using @track is for internal reactive state, not for accepting data from a parent.\n\n\ud83d\udca1 Remember: @api = public property that accepts data from parent; @track = private reactive state.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "@api",
        "isCorrect": true
      },
      {
        "content": "@wire",
        "isCorrect": false
      },
      {
        "content": "@track",
        "isCorrect": false
      },
      {
        "content": "@future",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A parent component needs to pass the value 'accountId' into a child Lightning Web Component. Which decorator should be used on the child property? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "\u2705 Use @api to make accountId public and available to parent components. LWC uses decorators for metadata\u2014@api marks properties that can be set from outside the component.\n\n\u274c Private properties (no decorator) cannot be accessed by parent components. The parent's template binding would fail silently.\n\n\ud83d\udca1 Think of @api as the 'public' keyword in object-oriented programming\u2014it defines the component's public interface.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "@api",
        "isCorrect": true
      },
      {
        "content": "@wire",
        "isCorrect": false
      },
      {
        "content": "@track",
        "isCorrect": false
      },
      {
        "content": "@future",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A Lightning Web Component needs to read Account data and refresh automatically when the record changes. Which approach should be used? Choose 1 answer.",
    "codeSnippet": "import { LightningElement, api, wire } from 'lwc';\nimport { getRecord, getFieldValue } from 'lightning/uiRecordApi';\nimport NAME_FIELD from '@salesforce/schema/Account.Name';\nimport INDUSTRY_FIELD from '@salesforce/schema/Account.Industry';\n\nexport default class AccountDetail extends LightningElement {\n    @api recordId;\n\n    @wire(getRecord, { recordId: '$recordId', fields: [NAME_FIELD, INDUSTRY_FIELD] })\n    account;\n\n    get name() {\n        return getFieldValue(this.account.data, NAME_FIELD);\n    }\n}",
    "explanation": "@wire with getRecord from lightning/uiRecordApi provides reactive, cached data that automatically refreshes when the record changes. It respects FLS and sharing without custom Apex. A Visualforce controller requires server roundtrips. Triggers and batch jobs run server-side and cannot feed data to UI components reactively.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "Use @wire with getRecord from lightning/uiRecordApi",
        "isCorrect": true
      },
      {
        "content": "Use a Visualforce controller",
        "isCorrect": false
      },
      {
        "content": "Use an Apex trigger",
        "isCorrect": false
      },
      {
        "content": "Use a batch job",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A Lightning Web Component needs to read Opportunity data and refresh automatically when the record changes. Which approach should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "@wire with getRecord from lightning/uiRecordApi provides reactive, cached data that automatically refreshes when the record changes. It respects FLS and sharing without custom Apex. A Visualforce controller requires server roundtrips. Triggers and batch jobs run server-side and cannot feed data to UI components reactively.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "Use @wire with getRecord from lightning/uiRecordApi",
        "isCorrect": true
      },
      {
        "content": "Use a Visualforce controller",
        "isCorrect": false
      },
      {
        "content": "Use an Apex trigger",
        "isCorrect": false
      },
      {
        "content": "Use a batch job",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A developer needs to call an Apex method from a Lightning Web Component to retrieve a list of Accounts. Which annotation is required on the Apex method? Choose 1 answer.",
    "codeSnippet": "// LWC calling Apex imperatively\nimport { LightningElement } from 'lwc';\nimport getAccounts from '@salesforce/apex/AccountController.getAccounts';\n\nexport default class AccountList extends LightningElement {\n    accounts;\n    error;\n\n    connectedCallback() {\n        this.loadAccounts();\n    }\n\n    loadAccounts() {\n        getAccounts()\n            .then(result => {\n                this.accounts = result;\n                this.error = undefined;\n            })\n            .catch(error => {\n                this.error = error;\n                this.accounts = undefined;\n            });\n    }\n}",
    "explanation": "@AuraEnabled is required on any Apex method called from LWC or Aura. The method must also be static and public. @InvocableMethod exposes methods to Flow Builder, not LWC. @RemoteAction is for Visualforce JavaScript Remoting (legacy). @TestVisible makes private methods accessible in tests only.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "@AuraEnabled",
        "isCorrect": true
      },
      {
        "content": "@InvocableMethod",
        "isCorrect": false
      },
      {
        "content": "@RemoteAction",
        "isCorrect": false
      },
      {
        "content": "@TestVisible",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "A developer needs to call an Apex method from a Lightning Web Component to fetch related Contacts. Which annotation is required on the Apex method? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "@AuraEnabled is required on any Apex method called from LWC or Aura. The method must also be static and public. @InvocableMethod exposes methods to Flow Builder, not LWC. @RemoteAction is for Visualforce JavaScript Remoting (legacy). @TestVisible makes private methods accessible in tests only.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "@AuraEnabled",
        "isCorrect": true
      },
      {
        "content": "@InvocableMethod",
        "isCorrect": false
      },
      {
        "content": "@RemoteAction",
        "isCorrect": false
      },
      {
        "content": "@TestVisible",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A developer needs a simple UI to edit a record while respecting CRUD/FLS without writing Apex. Which option is best? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Lightning Data Service (LDS) components like lightning-record-form, lightning-record-edit-form, and lightning-record-view-form automatically enforce CRUD and FLS, require no Apex, and share a client-side cache across components. A custom Apex controller would require manual FLS checks. Triggers and batch jobs are server-side processing, not UI tools.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "Use Lightning Data Service (e.g., lightning-record-form)",
        "isCorrect": true
      },
      {
        "content": "Use a custom Apex controller",
        "isCorrect": false
      },
      {
        "content": "Use a trigger",
        "isCorrect": false
      },
      {
        "content": "Use a batch job",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A developer needs a simple UI to view a record while respecting CRUD/FLS without writing Apex. Which option is best? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Lightning Data Service (LDS) components like lightning-record-form, lightning-record-edit-form, and lightning-record-view-form automatically enforce CRUD and FLS, require no Apex, and share a client-side cache across components. A custom Apex controller would require manual FLS checks. Triggers and batch jobs are server-side processing, not UI tools.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "Use Lightning Data Service (e.g., lightning-record-form)",
        "isCorrect": true
      },
      {
        "content": "Use a custom Apex controller",
        "isCorrect": false
      },
      {
        "content": "Use a trigger",
        "isCorrect": false
      },
      {
        "content": "Use a batch job",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "From an LWC button click, a user should be navigated to a Account record page. Which API should be used? Choose 1 answer.",
    "codeSnippet": "// LWC NavigationMixin for record navigation\nimport { LightningElement } from 'lwc';\nimport { NavigationMixin } from 'lightning/navigation';\n\nexport default class NavigateToRecord extends NavigationMixin(LightningElement) {\n\n    handleNavigate(event) {\n        const accountId = event.target.dataset.recordId;\n\n        this[NavigationMixin.Navigate]({\n            type: 'standard__recordPage',\n            attributes: {\n                recordId: accountId,\n                objectApiName: 'Account',\n                actionName: 'view'\n            }\n        });\n    }\n}",
    "explanation": "NavigationMixin is imported from lightning/navigation and mixed into the LWC class. It provides this[NavigationMixin.Navigate]() to navigate to record pages, list views, custom tabs, and more. Lightning Data Service reads/writes data but does not navigate. @wire fetches data. @future is server-side async.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "NavigationMixin",
        "isCorrect": true
      },
      {
        "content": "Lightning Data Service",
        "isCorrect": false
      },
      {
        "content": "@wire",
        "isCorrect": false
      },
      {
        "content": "Apex @future",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "From an LWC button click, a user should be navigated to a Opportunity record page. Which API should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "NavigationMixin is imported from lightning/navigation and mixed into the LWC class. It provides this[NavigationMixin.Navigate]() to navigate to record pages, list views, custom tabs, and more. Lightning Data Service reads/writes data but does not navigate. @wire fetches data. @future is server-side async.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "NavigationMixin",
        "isCorrect": true
      },
      {
        "content": "Lightning Data Service",
        "isCorrect": false
      },
      {
        "content": "@wire",
        "isCorrect": false
      },
      {
        "content": "Apex @future",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A developer needs to communicate between two LWCs on the same page. Which feature should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Lightning Message Service (LMS) enables pub/sub communication between LWC, Aura, and Visualforce components on the same page, even when they are in different DOM trees (e.g., utility bar vs. record page). It uses Message Channels defined in metadata. Parent-child communication uses @api and custom events instead.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "Lightning Message Service",
        "isCorrect": true
      },
      {
        "content": "Apex trigger",
        "isCorrect": false
      },
      {
        "content": "Workflow rule",
        "isCorrect": false
      },
      {
        "content": "Schema Builder",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "A developer needs to communicate between an LWC in a utility bar and one on a record page. Which feature should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Lightning Message Service (LMS) enables pub/sub communication between LWC, Aura, and Visualforce components on the same page, even when they are in different DOM trees (e.g., utility bar vs. record page). It uses Message Channels defined in metadata. Parent-child communication uses @api and custom events instead.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "Lightning Message Service",
        "isCorrect": true
      },
      {
        "content": "Apex trigger",
        "isCorrect": false
      },
      {
        "content": "Workflow rule",
        "isCorrect": false
      },
      {
        "content": "Schema Builder",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "An admin wants to add a component to a record page without code. Which tool should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Lightning App Builder is a drag-and-drop tool for composing Lightning pages without code. Admins can add standard components, custom LWC/Aura components, and configure page layouts. It supports record pages, app pages, and home pages. Developer Console is for writing code. Data Loader imports data.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "Lightning App Builder",
        "isCorrect": true
      },
      {
        "content": "Apex triggers",
        "isCorrect": false
      },
      {
        "content": "Data Loader",
        "isCorrect": false
      },
      {
        "content": "Developer Console",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 2,
    "content": "An admin wants to add a custom tab to a Lightning page without code. Which tool should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Lightning App Builder is a drag-and-drop tool for composing Lightning pages without code. Admins can add standard components, custom LWC/Aura components, and configure page layouts. It supports record pages, app pages, and home pages. Developer Console is for writing code. Data Loader imports data.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "Lightning App Builder",
        "isCorrect": true
      },
      {
        "content": "Apex triggers",
        "isCorrect": false
      },
      {
        "content": "Data Loader",
        "isCorrect": false
      },
      {
        "content": "Developer Console",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "An LWC calls an Apex method to fetch a read-only list of Accounts. Which annotation should be used for optimal performance? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "@AuraEnabled(cacheable=true) enables client-side caching for read-only methods, improving performance by avoiding redundant server calls. Cacheable methods can be used with @wire for reactive data binding. Without cacheable=true, @wire cannot be used. @InvocableMethod is for Flow, not LWC. @TestVisible is for test access only.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "@AuraEnabled(cacheable=true)",
        "isCorrect": true
      },
      {
        "content": "@AuraEnabled",
        "isCorrect": false
      },
      {
        "content": "@InvocableMethod",
        "isCorrect": false
      },
      {
        "content": "@TestVisible",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "An LWC calls an Apex method to fetch a read-only summary data. Which annotation should be used for optimal performance? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "@AuraEnabled(cacheable=true) enables client-side caching for read-only methods, improving performance by avoiding redundant server calls. Cacheable methods can be used with @wire for reactive data binding. Without cacheable=true, @wire cannot be used. @InvocableMethod is for Flow, not LWC. @TestVisible is for test access only.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "@AuraEnabled(cacheable=true)",
        "isCorrect": true
      },
      {
        "content": "@AuraEnabled",
        "isCorrect": false
      },
      {
        "content": "@InvocableMethod",
        "isCorrect": false
      },
      {
        "content": "@TestVisible",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "An LWC should call Apex in response to a button click rather than automatically. Which approach should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Imperative Apex calls are invoked explicitly from JavaScript (e.g., in a button click handler) rather than automatically on component load. Import the method and call it as a promise: getAccounts().then(result => ...). @wire with cacheable=true runs automatically when parameters change -- not suitable for user-initiated actions.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "Imperative Apex call from JavaScript",
        "isCorrect": true
      },
      {
        "content": "@wire with cacheable=true",
        "isCorrect": false
      },
      {
        "content": "Apex trigger",
        "isCorrect": false
      },
      {
        "content": "Workflow rule",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "An LWC should call Apex in response to a custom modal save action rather than automatically. Which approach should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Imperative Apex calls are invoked explicitly from JavaScript (e.g., in a button click handler) rather than automatically on component load. Import the method and call it as a promise: getAccounts().then(result => ...). @wire with cacheable=true runs automatically when parameters change -- not suitable for user-initiated actions.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "Imperative Apex call from JavaScript",
        "isCorrect": true
      },
      {
        "content": "@wire with cacheable=true",
        "isCorrect": false
      },
      {
        "content": "Apex trigger",
        "isCorrect": false
      },
      {
        "content": "Workflow rule",
        "isCorrect": false
      }
    ]
  },
  {
    "examType": "PD1",
    "topic": "user-interface",
    "type": "SINGLE_CHOICE",
    "difficulty": 3,
    "content": "An LWC should call Apex in response to a form submit event rather than automatically. Which approach should be used? Choose 1 answer.",
    "codeSnippet": null,
    "explanation": "Imperative Apex calls are invoked explicitly from JavaScript (e.g., in a button click handler) rather than automatically on component load. Import the method and call it as a promise: getAccounts().then(result => ...). @wire with cacheable=true runs automatically when parameters change -- not suitable for user-initiated actions.",
    "referenceUrl": "https://developer.salesforce.com/docs/platform/lwc/guide/get-started-introduction",
    "isPremium": false,
    "answers": [
      {
        "content": "Imperative Apex call from JavaScript",
        "isCorrect": true
      },
      {
        "content": "@wire with cacheable=true",
        "isCorrect": false
      },
      {
        "content": "Apex trigger",
        "isCorrect": false
      },
      {
        "content": "Workflow rule",
        "isCorrect": false
      }
    ]
  }
]